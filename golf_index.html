<canvas id="stage" width="600" height="520" style="border:1px solid grey;"></canvas>
<script>
/**
 * MODELS
 */
class Player {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.maxbomb = 1;
    this.reach = 2;
  }
  pos() {
    return [this.x, this.y];
  }
}
/**
 * Library
 */
const newBoard = () => {
  let board = [];
  for (let y = 0; y < 13; y++) {
    row = [];
    for (let x = 0; x < 15; x++) {
      if (x == 0 || y == 0 || y == 12 || x == 14 || (x%2 == 0 && y % 2 ==0)) {
        row.push('#');
      } else {
        row.push('x');
      }
    }
    board.push(row);
  }
  board[1][1] = '.';
  board[2][1] = '.';
  board[1][2] = '.';
  board[11][13] = '.';
  board[10][13] = '.';
  board[11][12] = '.';
  return board;
};


const initAssets = () => {
  bombImg = new Image();
  bombImg.src = 'img/bomb.png';
  p1Img = new Image();
  p1Img.src = 'img/p1.png';
  fireImg = new Image();
  fireImg.src = 'img/fire.png';
  crossImg = new Image();
  crossImg.src = 'img/cross.png';
  bombPowerup = new Image();
  bombPowerup.src = 'img/bomb_powerup.png';
  rangePowerup = new Image();
  rangePowerup.src = 'img/range_powerup.png';
};

const initGlobals = () => {
  bombs = []
  fire = []
  crosses = []
  rangePowerups = []
  bombPowerups = []
  board = newBoard();
  for (let i =0 ; i< 30; i++) {
    let nx = Math.random()*15|0, ny = Math.random()*13|0;
    if (board[ny][nx] != '#') {
      if (i % 2 == 0) {
        bombPowerups.push([nx, ny]);
      } else {
        rangePowerups.push([nx,ny]);
      }
    }
  }
  players = [new Player(40, 40), new Player(40*13,40*11)]
  p2 = [40*13,40*11]
  p2dir = 0;
  D=document;
  C=D[Q='querySelector']('canvas').getContext('2d');
  dim = 40;
  BOMB_TIME = 2000;
  FIRE_TIME = 500;
};

const align = (val) => {
  return Math.round(val/40)*40;
};
const toGrid = (x, y) => {
  return [Math.floor(x/40), Math.floor(y/40)]
};
const atBoard = ([x, y]) => {
  return board[y][x];
};

const paintSquare = (x, y, color) => {
  C.fillStyle='#333';
  C.fillRect(x,y,dim,dim);
  C.fillStyle=color;
  C.fillRect(x+1,y+1,dim-2,dim-2);
};

const fixAlignment = (player) =>{
  maxFix = 13;
  if (player.dir==1 || player.dir == 3) {
    if (Math.abs(player.x%40)<=maxFix || player.x%40 >= (40-maxFix)){
      player.x+=maxFix;
      player.x-= (player.x%40);
    } else {
      player.dir = 0;
    }
  }
  if (player.dir==2 || player.dir == 4) {
    if (Math.abs(player.y%40)<=maxFix || player.y%40 >= (40-maxFix)){
      player.y+=maxFix;
      player.y-= (player.y%40);
    } else {
      player.dir = 0;
    }
  }
  player.x = Math.max(40, player.x);
  player.y = Math.max(40, player.y);
  return player;
};

const explodeBomb = ([x, y,_,reach,id]) => {
  recFire(x-1, y, [1,0], 1);
  recFire(x, y, [0,1], reach);
  recFire(x, y, [1,0], reach);
  recFire(x, y, [0,-1], reach);
  recFire(x, y, [-1,0], reach);
};

const checkItems = () => {
  const now = Date.now();
  for (const b of bombs) {
    for (const f of fire) {
      if (f[0] == b[0] && f[1] == b[1]) {
        b[2] = 0;
      }
    }
    if (now >= b[2]) {
      explodeBomb(b);
      continue;
    }
  }
  bombs = bombs.filter((b) => now < b[2]);
  fire = fire.filter((f) => now < f[2]);
  for (const player of players) {
    for (const p of rangePowerups) {
      if (collides([player.x, player.y], p)) {
        rangePowerups = rangePowerups.filter(r=>r.x != p.x || r.y != p.y);
        player.reach += 1;
      }
    }
    for (const p of bombPowerups) {
      if (collides([player.x, player.y], p)) {
        bombPowerups = bombPowerups.filter(r=>r.x != p.x || r.y != p.y);
        player.maxbomb += 1;
      }
    }
  }
};

const getFireOpacity = (timestamp) => {
  const res =  (timestamp-Date.now())/FIRE_TIME;
  return Math.max(0, res/2+0.5);
};

initAssets();
initGlobals();

// Player 1
D.addEventListener('keydown', (e) => {
  let playerid = 0;
  const player = players[playerid];
  if (player.dead) {
    return;
  }
  switch(e.code){
    case 'ArrowUp': 
      player.dir = 1;
      break;
    case 'ArrowRight': 
      player.dir = 2;
      break;
    case 'ArrowDown': 
      player.dir = 3;
      break;
    case 'ArrowLeft': 
      player.dir = 4;
      break;
    case 'Space':
      curbombs = bombs.filter((b)  => b[4] == playerid).length;
      if (curbombs < player.maxbomb) {
        bombs.push([align(player.x)/40, align(player.y)/40, Date.now()+BOMB_TIME, player.reach, playerid]);
      }
      break;
  }});
D.addEventListener('keyup', (e) => {
  const curdir = players[0].dir;
  switch(e.code) {
    case 'ArrowUp': 
      players[0].dir = curdir == 1 ? 0 :curdir;
      break;
    case 'ArrowRight': 
      players[0].dir = curdir == 2 ? 0 :curdir;
      break;
    case 'ArrowDown': 
      players[0].dir = curdir == 3 ? 0 :curdir;
      break;
    case 'ArrowLeft': 
      players[0].dir = curdir == 4 ? 0 :curdir;
      break;
  }});

// Player 2
D.addEventListener('keydown', (e) => {
  const playerid = 1;
  const player = players[playerid];
  if (player.dead) {
    return;
  }
  switch(e.code){
    case 'KeyW': 
      player.dir = 1;
      break;
    case 'KeyD': 
      player.dir = 2;
      break;
    case 'KeyS': 
      player.dir = 3;
      break;
    case 'KeyA': 
      player.dir = 4;
      break;
    case 'Backquote':
      curbombs = bombs.filter((b)  => b[4] == playerid).length;
      if (curbombs < player.maxbomb) {
        bombs.push([align(player.x)/40, align(player.y)/40, Date.now()+BOMB_TIME, player.reach, playerid]);
      }
      break;
  }});
D.addEventListener('keyup', (e) => {
  const curdir = players[1].dir;
  switch(e.code) {
    case 'KeyW': 
      players[1].dir = curdir == 1 ? 0 : curdir;
      break;
    case 'KeyD': 
      players[1].dir = curdir == 2 ? 0 :curdir;
      break;
    case 'KeyS': 
      players[1].dir = curdir == 3 ? 0 :curdir;
      break;
    case 'KeyA': 
      players[1].dir = curdir == 4 ? 0 :curdir;
      break;
  }});



const draw=()=>{
  C.fillStyle='#FFF';
  C.fillRect(0,0,600,520);
  C.fillStyle='#bbb';
  for (x = 0; x < 15; x++){
    for (y = 0; y < 13; y++) {
      if (board[y][x] === '#') {
        paintSquare(x*dim, y*dim, '#bbb');
      } else if (board[y][x] === 'x') {
        paintSquare(x*dim, y*dim, '#cfa');
      } else {
        paintSquare(x*dim, y*dim, '#0b0');
      }
    }
  }
  drawItems(bombs);
  for (const p of players) {
    if (p.dead !== true) {
      C.drawImage(p1Img, p.x, p.y);
    }
  }
};

const drawItems = (bombs)  => {
  for (const b of bombs) {
    C.drawImage(bombImg, b[0]*40, b[1]*40);
  }
  for (const f of fire) {
    C.save();
    C.globalAlpha = getFireOpacity(f[2]);
    C.drawImage(fireImg, f[0]*40, f[1]*40);
    C.restore();
  }
  for (const  c of crosses) {
    C.drawImage(crossImg, c[0]*40, c[1]*40);
  }
  for (const rp of rangePowerups) {
    if (board[rp[1]][rp[0]] == '.') {
      C.drawImage(rangePowerup, rp[0]*40, rp[1]*40);
    }
  }
  for (const rp of bombPowerups) {
    if (board[rp[1]][rp[0]] == '.') {
      C.drawImage(bombPowerup, rp[0]*40, rp[1]*40);
    }
  }
};

const collides = ([x,y], [x2, y2]) => {
  const minX = Math.floor(x/40);
  const maxX = Math.ceil(x/40);
  const minY = Math.floor(y/40);
  const maxY = Math.ceil(y/40);
  console.log('minx', minX, maxX, minY, maxY);
  for(let x = minX; x <= maxX; x++) {
    for(let y = minY; y <= maxY; y++) {
      if (x == x2 && y == y2) {
        return true;
      }
    } 
  }
  return false;
}

const overlapsBlock = ([x, y], blockingKeys = '#x') => {
  const minX = Math.floor(x/40);
  const maxX = Math.ceil(x/40);
  const minY = Math.floor(y/40);
  const maxY = Math.ceil(y/40);
  for(let x = minX; x <= maxX; x++) {
    for(let y = minY; y <= maxY; y++) {
      if(blockingKeys.indexOf(board[y][x]) >= 0) {
        return true;
      }
    } 
  }
  return false;
};

const updatePlayer = (player) => {
    let tmpPos = [player.x, player.y];
    if(player.dir == 1) { tmpPos[1] -= 4; }
    if(player.dir == 2) { tmpPos[0] += 4; }
    if(player.dir == 3) { tmpPos[1] += 4; }
    if(player.dir == 4) { tmpPos[0] -= 4; }
    if (!overlapsBlock(tmpPos)) {
      player.x = tmpPos[0];
      player.y = tmpPos[1];
    }
    return player;
}

const recFire = (x, y, [xmod, ymod], stepsLeft) => {
  if (stepsLeft == 0) {
    return;
  }
  let newx = x + xmod;
  let newy = y + ymod;
  if (board[newy][newx] != '#') {
    fire.push([newx, newy, Date.now() + FIRE_TIME]);
  } else {
    return;
  }
  if (board[newy][newx] == 'x') {
    board[newy][newx] = '.';
    return;
  }
  recFire(newx, newy, [xmod, ymod], stepsLeft-1);
}

const checkForDeath = (player) => {
  let x = player.x;
  let y = player.y;

  const pts = [[x+5,y+5],[x+35,y+5], [x+5, y+35], [x+35, y+35]];
  for (const p of pts) {
    const grid = toGrid(p[0], p[1]);
    for (const f of fire) {
      if (grid[0] == f[0] && grid [1] == f[1]) {
        player.dead = true;
        crosses.push([grid[0], grid[1]]);
        return;
      }
    }
  }
};

let lastTick = 0;
const step = (t) => {
  if (t - lastTick > 16) {
    for (let i = 0; i < players.length; i++) {
      players[i] = fixAlignment(players[i]);
      players[i] = updatePlayer(players[i]);
      players[i] = fixAlignment(players[i]);
    }
    lastTick = t;
  }
  checkItems();
  for (const p of players) {
    checkForDeath(p);
  }
  requestAnimationFrame(step);
  draw();
};

requestAnimationFrame(step);
</script>
